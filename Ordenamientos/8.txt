-----------------------Aclaracion---------------------------------
Si bien en el ejercicio solamente se pide por genero, se podria dar el caso de que ademas pidan por anio, en tal caso
ya deje el algoritmo correspondiente. notar que si simplemente se ignora ese subalgoritmo el ordenamiento funcionaria perfectamente.
ALGORITMO OrdenarPeliculasPorGenero(peliculas)
  // Crear mapa de buckets((mapa en go seria el equivalente a diccionario en python))
  buckets := mapa[string]lista_peliculas{}
  
  // Distribuir películas en buckets
  para pelicula := rango peliculas hacer
    si buckets[pelicula.genero] == nil entonces
      buckets[pelicula.genero] = lista_vacia()
    fin si
    buckets[pelicula.genero].append(pelicula)
  fin para
  
  // Obtener géneros como slice y ordenar
  generos := slice_vacio()
  para genero := rango buckets hacer
    generos.append(genero)
  fin para
  ordenar_strings(generos)
  
  // Ordenar cada bucket por año usando insertion sort
  para genero := rango generos hacer
    insertionSort(buckets[genero])
  fin para
  
  // Concatenar buckets en resultado final
  resultado := slice_vacio()
  para genero := rango generos hacer
    resultado.append(buckets[genero]...)
  fin para
  
  retornar resultado
fin algoritmo
--------ordenaminto por anio----------
SUBALGORITMO insertionSort(peliculas)
  para i := 1 hasta len(peliculas)-1 hacer
    clave := peliculas[i]
    j := i - 1
    mientras j >= 0 Y peliculas[j].año > clave.año hacer
      peliculas[j+1] = peliculas[j]
      j = j - 1
    fin mientras
    peliculas[j+1] = clave
  fin para
fin subalgoritmo

